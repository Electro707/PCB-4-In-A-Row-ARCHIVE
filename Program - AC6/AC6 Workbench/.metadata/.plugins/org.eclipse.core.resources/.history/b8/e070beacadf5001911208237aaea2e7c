/**
  ******************************************************************************
  * @file    main.c
  * @author  Ac6
  * @version V1.0
  * @date    01-December-2013
  * @brief   Default main function.
  ******************************************************************************
*/


#include "stm32f10x.h"
#include "delay.h"

// Some color definition
#define RED 0b001
#define GREEN 0b010
#define BLUE 0b100
#define PURPLE 0b101
#define CYAN 0b110
#define YELLOW 0b011
#define WHITE 0b111

#define PLAYER1COLOR RED
#define PLAYER2COLOR YELLOW

#define INDICATE_BLUE GPIOC->ODR = 0b100;
#define INDICATE_YELLOW GPIOC->ODR = 0b011;
#define INDICATE_GREEN GPIOC->ODR = 0b010;
#define INDICATE_RED GPIOC->ODR = 0b001;

// Array of the LED matrix
// Store each integer as a column, each array index as row
// For each column, store each bit as a color (0b111 = BGR)
int LED[6];

// Void to set up the interupt to update the LEDs
// The interupt handler will execute, for now, about once every 1 mS
void LEDInteruptSetup(void){
	__enable_irq();
	NVIC_EnableIRQ(TIM6_IRQn);

	RCC->APB1ENR |= (1<<4); // Turn on tim6 clock
	TIM6->CR1 &= ~(1<<0); // Disable Counter
	TIM6->CR1 |= (1<<2); // Set so only overflow/underflow generates event
	TIM6->CR1 &= ~(1<<3); //Turn off one-pulse mode
	TIM6->PSC = 141; // Set prescaler
	TIM6->DIER |= (1<<0); // Enable Interupt
	TIM6->CNT = 0x00; // Clear the timer
	TIM6->ARR = 0x00FF; // Set count value to

	TIM6->EGR |= (1<<0);// Update register
}
// Define to start the timer, thus start the interupt
#define LEDInteruptStart TIM6->CR1 |= (1<<0); // Enable Counter

// Array for player location
// First dimension is for column, where it's 2 bit per LED ( to account for 2 players plus X)
// Second dimension is for each row
uint16_t players[6];
// 1 for player 1, 2 for player 2
uint8_t active_player = 0;

// Function to take player's location and convert it to an LED matrix
void playerToLed(){
	// Clear LED buffer
	for(int r=0;r<6;r++){LED[r] = 0;}

	for(int r=0;r<6;r++){
		for(int c=0;c<7;c++){
			uint8_t playerAtLoc = (players[r] >> c*2) & 0b11;
			if(playerAtLoc == 0b01){
				LED[r] |= (PLAYER1COLOR << c*3);
			}
			else if(playerAtLoc == 0b10){
				LED[r] |= (PLAYER2COLOR << c*3);
			}
		}
	}
}

void clearPlayers(){
	for(int i=0;i<6;i++){
		players[i] = 0;
	}
}
int waitForRowInput(){
	int buttons = 0;
	int position = 0;
	while(1){
		buttons = (GPIOC->IDR >> 3) & 0b1111111;
		if(buttons != 0b1111111){
			break;
		}
	}
	for(int i=0;i<7;i++){
		if((buttons >> i) & 0b1 == 0){
			break;
		}
	}

}
int main(void)
{

	// Initialization stuff
	SystemInit();
	delaySetup();

	RCC->APB2ENR |= (1<<4); 	// Enable PORTC clock
	RCC->APB2ENR |= (1<<3); 	// Enable PORTB clock
	RCC->APB2ENR |= (1<<2); 	// Enable PORTA clock
	RCC->APB2ENR |= (1<<0);		// Enable Alternate Function clock
	// Remap PB3 and PB4 so they can act as output
	AFIO->MAPR |= (0b010<<24);
	// Enable single-RGB led output pins as...outputs (Max of 2Mhz, 0b0010 per pin)
	GPIOC->CRL &= ~(0xFFF<<0);
	GPIOC->CRL |= (0x222<<0);
	// Enable the pushbutton with internal pullup (0b1000 per pin)
	GPIOC->CRL &= ~(0xFFFFF<<3);
	GPIOC->CRL |= (0x88888<<3);
	GPIOC->CRH &= ~(0xFFFF<<3);
	GPIOC->CRH |= (0x8888<<3);
	GPIOC->ODR |= (0b111111111<<3);	// Enable internal pullup

	// Set GPIOB and GPIOA pins to outputs (the ones meant as output) (0b0001 or 0x1 per pin)
	GPIOA->CRL = 0x11111114;
	GPIOA->CRH = 0x44411111;
	GPIOB->CRL = 0x11111111;
	GPIOB->CRH = 0x11111141;

	LEDInteruptSetup();
	LEDInteruptStart

	uint8_t row = 0;
	uint8_t p = 1;
	uint8_t column = 0;
	while(1){
		clearPlayers();

		players[row] = p << (column*2);
		playerToLed();

		p = ( (p == 1) ? 2 : 1 );
		delayMs(500);
		row++;
		if(row >= 6){
			row = 0;
			column++;
			if(column >= 7){
				column = 0;
			}
		}
	}

}


//uint8_t ledMode = 0;

uint8_t InteruptRowCounter = 0;
void TIM6_IRQHandler(void){
	TIM6->SR = 0x00; // Clear statue

	int gpioAodr = 0;
	int gpioBodr = 0;

	gpioAodr |= (LED[InteruptRowCounter] & 0b1111111) << 1;
	gpioAodr |= ((LED[InteruptRowCounter] >> 16) & 0b11111) << 8;

	gpioBodr |= ((LED[InteruptRowCounter] >> 7) & 0b111);
	gpioBodr |= ((LED[InteruptRowCounter] >> 10) & 0b111111) << 10;
	gpioBodr |= (1<<((5-InteruptRowCounter)+3));

	GPIOA->ODR = gpioAodr;
	GPIOB->ODR = gpioBodr;

	InteruptRowCounter++;
	if(InteruptRowCounter > 5){
		InteruptRowCounter = 0;
	}
}
